---
title: "Homework 6 Site - Evan Gray"
format: html
toc: TRUE
editor_options: 
  chunk_output_type: inline
---

...Trying a different html theme

# Conceptual Questions

1.  What is the purpose of the lapply() function? What is the equivalent purrr function?

<div>

lapply() is a function used to execute a function across multiple list objects, it is meant to be a more efficient to loops. Map() is an equivalent purrr tidyverse function.

</div>

2.  Suppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want to use lapply() to run the code cor(numeric_matrix, method = "kendall") on each element of the list. Write code to do this.

```{r}
#list df1 - correlated
x <- c(seq(1,5,1))
y <- c(seq(2,10,2))
df1 <- data.frame(x,y)

#list df2 - probably not correlated
set.seed(1)
a <- rnorm(5,10,50)
b <- runif(5,0,1)
df2 <- data.frame(a,b)

#create list
testlist <- list(df1,df2)

#lapply with additional argument listed following a comma NOT within parentheses
newcor <- lapply(X = testlist, FUN = cor, method = "kendall")
newcor
```

3.  What are two advantages of using purrr functions instead of the base R apply family?

    <div>

    Some of the advantages of purrr:

    -   purrr functions such as map() allow for more concise and readable code. Its functions are written in C so they execute relatively quick.

    -   purrr functions have simply syntax for implementing anonymous functions "(x)" instead of " \<- function(x...)"

    </div>

4.  What is a side-effect function?

    <div>

    A side effect function does not return a "transformed" object. It simply performs some action with what it inputs (printing, plotting, saving, etc).

    </div>

5.  Why can you name a variable "sd" in a function and not cause any issues with the "sd" function?

    <div>

    This is because of lexical scoping - "where" R looks for objects you've coded. The inside of a function is a separate environment from outside so it doesn't look for the base R "sd" function as long as you've named an object "sd" INSIDE of the function.

    </div>

# RMSE Function Writing

```{r}
getRMSE <- function(predict, response,...){

  diffsq <- (c(predict-response))^2
  RMSE <- sqrt(mean(diffsq,...))

  return(RMSE)
}
```

```{r}
library(dplyr)
library(purrr)

#create test data

set.seed(10)
n <- 100
x <- runif(n)

resp <- 3+10*x+rnorm(n)
pred <- predict(lm(resp~x), data.frame(x))
```

## Test RMSE function

```{r}
#test function
getRMSE(pred,resp)
```

## Test RMSE function w NA values

```{r}
#manual change with missing
resp[3:5] <- c(NA_real_)

#test function w and w/o argument to deal with NAs
getRMSE(pred,resp)

getRMSE(pred,resp, na.rm = TRUE)
```

# MAE Function

```{r}

getMAE <- function(predict, response,...){

  absdiff <- c(abs(predict-response))
  MAE <- mean(absdiff,...)

  return(MAE)
}
```

## Test MAE function

```{r}
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

getMAE(pred,resp)
```

## Test MAE function w/ missing

```{r}
resp[7:8] <- c(NA_real_)

getMAE(pred,resp)

getMAE(pred,resp, na.rm = TRUE)

```

# Wrapper Function

```{r}
predEVAL <- function(prediction,response,method = "ALL",...){
    if ((!is.numeric(prediction) | !is.vector(prediction)) || (!is.numeric(response) | !is.vector(response))) {
    stop(print("choose two numeric vectors"))
    }
  
    MAE <- getMAE(prediction,response,...)
    RMSE <- getRMSE(prediction,response,...)
     
 result <- if (method == "MAE"){
      paste0("Mean Adjusted Error is ",round(MAE,digits=4))
    }
    else if (method == "RMSE"){
      paste0("Root Mean Square Error is ",round(RMSE,digits=4))
    }
    else if (method == "ALL"){
      paste0("Root Mean Square Error is ",round(RMSE,digits=4)," / Mean Adjusted Error is ",round(MAE,digits=4))
    }
 return(result)
}
```

## Test Wrapper Function

```{r}
#reset pred and resp
set.seed(10)
n <- 100
x <- runif(n)
resp <- 3 + 10 * x + rnorm(n)
pred <- predict(lm(resp ~ x), data.frame(x))

```

MAE Test

```{r}
predEVAL(pred,resp,method="MAE")
```

RMSE Test

```{r}
predEVAL(pred,resp,method="RMSE")
```

Both Metrics Test

```{r}
predEVAL(pred,resp)
```

## Test WRAPPER with NA

```{r}
resp[7:8] <- c(NA_real_)

predEVAL(pred,resp)
predEVAL(pred,resp,na.rm=TRUE)
```

## Test passing incorrect data to function

```{r, error=TRUE}
#create test vectors and df
a <- c("evan","debbie","canes")
b <- seq(1:3)
df <- data.frame(a,b)

predEVAL(a,b)
predEVAL(pred[1:3],df)
```

# Practice with purrr

```{r}
#Initial model
lm_fit1 <- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)

#accessing model coefficients
lm_fit1$coefficients
coef(lm_fit1)
pluck(lm_fit1,coefficients)

```

## Additional Models

```{r}
lm_fit2 <- lm(Sepal.Length ~ Sepal.Width, data = iris)
lm_fit3 <- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)
lm_fit4 <- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species, data = iris)
fits <- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)
```

## Return all coefficients objects for each list item of fits

```{r}
map(fits,"coefficients")
```

## for each list item of fits, operate confint()

```{r}
#confint() does not require coefficient specification
map(fits, \(x) confint(x))

```

## Plot1

```{r}
par(mfrow = c(2,2))
map(fits,"residuals") |> #creates list of 4 residual vectors
  walk(hist)

#other methods to pull residuals (2) for 1st fits object
#pluck(fits,1,2)
#resid(lm_fit1)
#resid(fits[[1]])
```

## Plot 2

```{r, error=TRUE}
par(mfrow = c(2,2))
map(fits,"residuals") |> #creates list of 4 residual vectors
set_names(c("fit1","fit2","fit3","fit4")) |> #inputs list and renames each vector
  iwalk(\(x, y) hist(x,main = y)) #don't know how to make this work...

```
